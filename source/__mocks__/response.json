{"title":"Progressive Web Apps with React.js: Part 2 — Page Load Performance","content":"<div><div><div class=\"section-content\"><div class=\"section-inner sectionLayout--outsetColumn\"><figure id=\"59a9\" class=\"graf graf--figure graf--layoutOutsetCenter graf-after--p\"><img class=\"progressiveMedia-noscript js-progressiveMedia-inner\" src=\"https://cdn-images-1.medium.com/max/2000/0*KlJk2hhZl3wyn6E4.\"></figure></div><div class=\"section-inner sectionLayout--insetColumn\"><p id=\"7868\" class=\"graf graf--p graf-after--figure\">It&#x2019;s always important to measure and then optimize. Lighthouse&#x2019;s load performance audits look at:</p><ul class=\"postList\"><li id=\"d89b\" class=\"graf graf--li graf-after--p\"><a href=\"https://www.quora.com/What-does-First-Meaningful-Paint-mean-in-Web-Performance\" class=\"markup--anchor markup--li-anchor\"><strong class=\"markup--strong markup--li-strong\">First meaningful paint</strong></a> (when is the main content of the page visible)</li><li id=\"da88\" class=\"graf graf--li graf-after--li\"><a href=\"https://sites.google.com/a/webpagetest.org/docs/using-webpagetest/metrics/speed-index\" class=\"markup--anchor markup--li-anchor\"><strong class=\"markup--strong markup--li-strong\">Speed Index</strong></a> (visual completeness)</li><li id=\"0abd\" class=\"graf graf--li graf-after--li\"><strong class=\"markup--strong markup--li-strong\">Estimated Input Latency</strong> (when is the main thread available to immediately handle user input)</li><li id=\"dbcf\" class=\"graf graf--li graf-after--li\">and <strong class=\"markup--strong markup--li-strong\">Time To Interactive</strong> (how soon is the app usable &amp; engagable)</li></ul><p id=\"41ab\" class=\"graf graf--p graf-after--li\"><em class=\"markup--em markup--p-em\">Btw, Paul Irish has done terrific work summarising </em><a href=\"https://www.youtube.com/watch?v=IxXGMesq_8s\" class=\"markup--anchor markup--p-anchor\"><em class=\"markup--em markup--p-em\">interesting metrics for PWAs</em></a><em class=\"markup--em markup--p-em\"> worth keeping an eye out.</em></p><p id=\"0589\" class=\"graf graf--p graf-after--p\"><strong class=\"markup--strong markup--p-strong\">Good performance goals:</strong></p><ul class=\"postList\"><li id=\"2e2d\" class=\"graf graf--li graf-after--p\"><strong class=\"markup--strong markup--li-strong\">Follow L in the </strong><a href=\"https://developers.google.com/web/tools/chrome-devtools/profile/evaluate-performance/rail?hl=en\" class=\"markup--anchor markup--li-anchor\"><strong class=\"markup--strong markup--li-strong\">RAIL performance model</strong></a><strong class=\"markup--strong markup--li-strong\">. </strong><em class=\"markup--em markup--li-em\">A+ performance is something all of us should be striving for even if a browser doesn&#x2019;t support Service Worker. We can still get something meaningful on the screen quickly &amp; only load what we need</em></li><li id=\"2f93\" class=\"graf graf--li graf-after--li\"><strong class=\"markup--strong markup--li-strong\">Under representative network (3G) &amp; hardware conditions</strong></li><li id=\"04c0\" class=\"graf graf--li graf-after--li\">Be interactive in &lt; 5s on first visit &amp; &lt; 2s on repeat visits once a Service Worker is active.</li><li id=\"dab4\" class=\"graf graf--li graf-after--li\">First load (network-bound), Speed Index of 3,000 or less</li><li id=\"8cc0\" class=\"graf graf--li graf-after--li\">Second load (disk-bound because SW): Speed Index of 1,000 or less.</li></ul><p id=\"afb2\" class=\"graf graf--p graf-after--li\">Let&#x2019;s talk a little more about focusing on interactivity via TTI.</p><p id=\"bb3a\" class=\"graf graf--p graf-after--h3\">Optimizing for interactivity means making the app usable for users as soon as possible (i.e enabling them to click around and have the app react). This is critical for modern web experiences trying to provide first-class user experiences on mobile.</p><figure id=\"cead\" class=\"graf graf--figure graf-after--p\"><img class=\"progressiveMedia-noscript js-progressiveMedia-inner\" src=\"https://cdn-images-1.medium.com/max/1600/0*qfZvSxxJxPHhXXgb.\"></figure><p id=\"047d\" class=\"graf graf--p graf-after--figure\">Lighthouse currently expresses TTI as a measure of when layout has stabilized, web fonts are visible and the main thread is available enough to handle user input. There are many ways of tracking TTI manually and what&#x2019;s important is optimising for metrics that result in experience improvements for your users.</p><p id=\"f9af\" class=\"graf graf--p graf-after--p\">For libraries like React, you should be concerned by the <a href=\"https://aerotwist.com/blog/the-cost-of-frameworks/\" class=\"markup--anchor markup--p-anchor\">cost of booting up the library</a> on mobile as this can catch folks out. In <a href=\"https://github.com/insin/react-hn\" class=\"markup--anchor markup--p-anchor\">ReactHN</a>, we accomplished interactivity in under <strong class=\"markup--strong markup--p-strong\">1700ms</strong> by keeping the size and execution cost of the overall app relatively small despite having multiple views: 11KB gzipped for our app bundle and 107KB for our vendor/React/libraries bundle which looks a little like this in practice:</p></div><div class=\"section-inner sectionLayout--outsetColumn\"><figure id=\"b615\" class=\"graf graf--figure graf--layoutOutsetCenter graf-after--p\"><img class=\"progressiveMedia-noscript js-progressiveMedia-inner\" src=\"https://cdn-images-1.medium.com/max/2000/0*N--j53GygKHn2ViI.\"></figure></div><div class=\"section-inner sectionLayout--insetColumn\"><p id=\"c27f\" class=\"graf graf--p graf-after--figure\">Later, for apps with granular functionality, we&#x2019;ll look at performance patterns like <a href=\"https://www.polymer-project.org/1.0/toolbox/server\" class=\"markup--anchor markup--p-anchor\">PRPL</a> which nail fast time-to-interactivity through granular &#x201C;route-based chunking&#x201D; while taking advantage of <a href=\"https://www.igvita.com/2013/06/12/innovating-with-http-2.0-server-push/\" class=\"markup--anchor markup--p-anchor\">HTTP/2 Server Push</a> (try the <a href=\"https://shop.polymer-project.org/\" class=\"markup--anchor markup--p-anchor\">Shop</a> demo to see what we mean).</p><p id=\"768c\" class=\"graf graf--p graf-after--p\">Housing.com recently shipped a React experience using a PRPL-like pattern to much praise:</p><figure id=\"ad70\" class=\"graf graf--figure graf--iframe graf-after--p\"><div class=\"aspectRatioPlaceholder is-locked\"></div></figure><figure id=\"9ec2\" class=\"graf graf--figure graf-after--figure\"><img class=\"progressiveMedia-noscript js-progressiveMedia-inner\" src=\"https://cdn-images-1.medium.com/max/1600/0*55ArR_Z3qt7Az_FW.\"><figcaption class=\"imageCaption\">Housing.com took advantage of Webpack route-chunking to defer some of the bootup cost of entry pages (loading only what is needed for a route to render). For more detail see <a href=\"https://twitter.com/samccone/status/771786445015035904\" class=\"markup--anchor markup--figure-anchor\">Sam Saccone&#x2019;s excellent Housing.com perf&#xA0;audit</a>.</figcaption></figure><p id=\"d17d\" class=\"graf graf--p graf-after--figure\">As did Flipkart:</p><figure id=\"5a93\" class=\"graf graf--figure graf--iframe graf-after--p\"><div class=\"aspectRatioPlaceholder is-locked\"></div></figure><p id=\"b58e\" class=\"graf graf--p graf-after--figure\">Note: There are many differing views on what &#x201C;time to interactive&#x201D; might mean and it&#x2019;s possible Lighthouse&#x2019;s definition of TTI will evolve. Other ways to track it could be the first point after a navigation where you can see a 5 second window with no long tasks or the first point after a text/content paint with a 5s window with no long tasks. Basically, how soon after the page settles is it likely a user will be able to interact with the app?</p><p id=\"5d4f\" class=\"graf graf--p graf-after--p\">Note:<em class=\"markup--em markup--p-em\"> </em>While not a firm requirement, you may also improve visual completeness (Speed Index) by <a href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/\" class=\"markup--anchor markup--p-anchor\">optimising the critical-rendering path</a>. <a href=\"https://github.com/addyosmani/critical-path-css-tools#node-modules\" class=\"markup--anchor markup--p-anchor\">Tooling for critical-path CSS optimisation exists</a> and this optimisation can still have wins in a world with HTTP/2.</p><p id=\"5269\" class=\"graf graf--p graf-after--h3\"><em class=\"markup--em markup--p-em\">If you&#x2019;re new to module bundling tools like Webpack, </em><a href=\"https://www.youtube.com/watch?v=OhPUaEuEaXk\" class=\"markup--anchor markup--p-anchor\"><em class=\"markup--em markup--p-em\">JS module bundlers</em></a><em class=\"markup--em markup--p-em\"> (video) might be a useful watch.</em></p><p id=\"6f20\" class=\"graf graf--p graf-after--p\">Some of today&#x2019;s JavaScript tooling makes it easy to bundle all of your scripts into a single bundle.js file that gets included in all pages.This means that a lot of the time, you&#x2019;re likely loading a lot of code that isn&#x2019;t required at all for the current route. Why load up 500KB of JS for a route when only 50KB will do? We should be throwing out script that isn&#x2019;t conducive to shipping a fast experience for booting up a route with interactivity</p><figure id=\"3df7\" class=\"graf graf--figure graf-after--p\"><img class=\"progressiveMedia-noscript js-progressiveMedia-inner\" src=\"https://cdn-images-1.medium.com/max/1600/0*z2tqS124xW0GDmcP.\"></figure><p id=\"37fc\" class=\"graf graf--p graf-after--figure\"><em class=\"markup--em markup--p-em\">Avoid serving large, monolithic bundles (like above) when just serving the minimum functionally viable code a user actually needs for a route will do.</em></p><p id=\"3d74\" class=\"graf graf--p graf-after--p\">Code-splitting is one answer to the problem of monolithic bundles. It&#x2019;s the idea that by defining split-points in your code, it can be split into different files that are lazy loaded on demand. This improves startup time and help us get to being interactive sooner.</p></div><div class=\"section-inner sectionLayout--outsetColumn\"><figure id=\"531c\" class=\"graf graf--figure graf--layoutOutsetCenter graf-after--p\"><img class=\"progressiveMedia-noscript js-progressiveMedia-inner\" src=\"https://cdn-images-1.medium.com/max/2000/0*c9rmq2rp95BN39qg.\"></figure></div><div class=\"section-inner sectionLayout--insetColumn\"><p id=\"e3f9\" class=\"graf graf--p graf-after--figure\">Imagine using an apartment listings app. If we land on a route listing the properties in our area (route-1)&#x200A;&#x2014;&#x200A;we don&#x2019;t need the code for viewing the full details for a property (route-2) or scheduling a tour (route-3), so we can serve users just the JavaScript needed for the listings route and dynamically load the rest.</p><p id=\"88c5\" class=\"graf graf--p graf-after--p\">This idea of code-splitting by route been used by many apps over the years, but is currently referred to as &#x201C;<a href=\"https://gist.github.com/addyosmani/44678d476b8843fd981ff8011d389724\" class=\"markup--anchor markup--p-anchor\">route-based chunking</a>&#x201D;. We can enable this setup for React using the Webpack module bundler.</p><p id=\"1f66\" class=\"graf graf--p graf-after--h3\">Webpack supports code-splitting your app into chunks wherever it notices a <a href=\"https://webpack.github.io/docs/code-splitting.html\" class=\"markup--anchor markup--p-anchor\">require.ensure()</a> being used (or in <a href=\"https://gist.github.com/sokra/27b24881210b56bbaff7\" class=\"markup--anchor markup--p-anchor\">Webpack 2</a>, a <a href=\"http://moduscreate.com/code-splitting-for-react-router-with-es6-imports/\" class=\"markup--anchor markup--p-anchor\">System.import</a>). These are called &#x201C;split-points&#x201D; and Webpack generates a separate bundle for each of them, resolving dependencies as needed.</p><pre id=\"7dfc\" class=\"graf graf--pre graf-after--p\">// Defines a &quot;split-point&quot;<br>require.ensure([], function () {<br>   const details = require(&apos;./Details&apos;);<br>   // Everything needed by require() goes into a separate bundle<br>   // require(deps, cb) is asynchronous. It will async load and evaluate<br>   // modules, calling cb with the exports of your deps.<br>});</pre><p id=\"878f\" class=\"graf graf--p graf-after--pre\">When your code needs something, Webpack makes a JSONP call to fetch it from the server. This works well with React Router and we can lazy-load in the dependencies (chunks) a new route needs before rendering the view to a user.</p><p id=\"87af\" class=\"graf graf--p graf-after--p\">Webpack 2 supports <a href=\"https://medium.com/modus-create-front-end-development/automatic-code-splitting-for-react-router-w-es6-imports-a0abdaa491e9#.3ryyedhfc\" class=\"markup--anchor markup--p-anchor\">automatic code-splitting with React Router</a> as it can treat System.import calls for modules as import statements, bundling imported filed and their dependencies together. Dependencies won&#x2019;t collide with the initial entry in your Webpack configuration.</p><pre id=\"9759\" class=\"graf graf--pre graf-after--p\">import App from &apos;../containers/App&apos;;</pre><pre id=\"fa74\" class=\"graf graf--pre graf-after--pre\">function errorLoading(err) {<br>  console.error(&apos;Lazy-loading failed&apos;, err);<br>}</pre><pre id=\"fe97\" class=\"graf graf--pre graf-after--pre\">function loadRoute(cb) {<br>  return (module) =&gt; cb(null, module.default);<br>}<br>export default {<br>  component: App,<br>  childRoutes: [<br>    // ...<br>    {<br>      path: &apos;booktour&apos;,<br>      getComponent(location, cb) {<br>        System.import(&apos;../pages/BookTour&apos;)<br>          .then(loadRoute(cb))<br>          .catch(errorLoading);<br>      }<br>    }<br>  ]<br>};</pre><p id=\"7716\" class=\"graf graf--p graf-after--h3\">Before we continue, one optional addition to your setup is <a href=\"https://www.smashingmagazine.com/2016/02/preload-what-is-it-good-for/\" class=\"markup--anchor markup--p-anchor\">&lt;link rel=&#x201D;preload&#x201D;&gt;</a> from <a href=\"https://twitter.com/addyosmani/status/743571393174872064\" class=\"markup--anchor markup--p-anchor\">Resource Hints</a>. This gives us a way to declaratively fetch resources without executing them. Preload can be leveraged for preloading Webpack chunks for routes users <em class=\"markup--em markup--p-em\">are likely</em> to navigate to so the cache is already primed with them and they&#x2019;re instantly available for instantiation.</p><figure id=\"346d\" class=\"graf graf--figure graf-after--p\"><img class=\"progressiveMedia-noscript js-progressiveMedia-inner\" src=\"https://cdn-images-1.medium.com/max/1600/0*l-XqjMw7_XX0wsxX.\"></figure><p id=\"4f83\" class=\"graf graf--p graf-after--figure\">At the time of writing, preload is only implemented in <a href=\"http://caniuse.com/#feat=link-rel-preload\" class=\"markup--anchor markup--p-anchor\">Chrome</a>, but can be treated as a progressive enhancement for browsers that do support it.</p><p id=\"31f6\" class=\"graf graf--p graf-after--p\">Note: html-webpack-plugin&#x2019;s <a href=\"https://github.com/ampedandwired/html-webpack-plugin#events\" class=\"markup--anchor markup--p-anchor\">templating and custom-events</a> can make setting this up a trivial process with minimal changes. You should however ensure that resources being preloaded are genuinely going to be useful for your averages users journey.</p><p id=\"d824\" class=\"graf graf--p graf-after--h3\">Back to code-splitting&#x200A;&#x2014;&#x200A;in an app using React and <a href=\"https://github.com/reactjs/react-router\" class=\"markup--anchor markup--p-anchor\">React Router</a>, we can use require.ensure() to asynchronously load a component as soon as ensure gets called. Btw, this needs to be shimmed in Node using the <a href=\"https://www.npmjs.com/package/node-ensure\" class=\"markup--anchor markup--p-anchor\">node-ensure</a> package for anyone exploring server-rendering. Pete Hunt covers async loading in <a href=\"https://github.com/petehunt/webpack-howto#9-async-loading\" class=\"markup--anchor markup--p-anchor\">Webpack How-to</a>.</p><p id=\"c23a\" class=\"graf graf--p graf-after--p\">In the below example, require.ensure() enables us to lazy load routes as needed, waiting on a component to be fetched before it is used:</p><pre id=\"4b30\" class=\"graf graf--pre graf-after--p\">const rootRoute = {<br>  component: Layout,<br>  path: &apos;/&apos;,<br>  indexRoute: {<br>    getComponent (location, cb) {<br>      require.ensure([], () =&gt; {<br>        cb(null, require(&apos;./Landing&apos;))<br>      })<br>    }<br>  },<br>  childRoutes: [<br>    {<br>      path: &apos;book&apos;,<br>      getComponent (location, cb) {<br>        require.ensure([], () =&gt; {<br>          cb(null, require(&apos;./BookTour&apos;))<br>        })<br>      }<br>    },<br>    {<br>      path: &apos;details/:id&apos;,<br>      getComponent (location, cb) {<br>        require.ensure([], () =&gt; {<br>          cb(null, require(&apos;./Details&apos;))<br>        })<br>      }<br>    }<br>  ]<br>}</pre><p id=\"6841\" class=\"graf graf--p graf-after--pre\"><em class=\"markup--em markup--p-em\">Note: I often use the above setup with the CommonChunksPlugin (with minChunks: Infinity) so I have one chunk with common modules between my different entry points. This also </em><a href=\"https://github.com/webpack/webpack/issues/368#issuecomment-247212086\" class=\"markup--anchor markup--p-anchor\"><em class=\"markup--em markup--p-em\">minimized</em></a><em class=\"markup--em markup--p-em\"> running into missing Webpack runtime.</em></p><p id=\"9779\" class=\"graf graf--p graf-after--p\">Brian Holt covers async route loading well in a <a href=\"https://btholt.github.io/complete-intro-to-react/\" class=\"markup--anchor markup--p-anchor\">Complete Intro to React</a>. Code-splitting with async routing is possible with both the current version of React Router and the <a href=\"https://gist.github.com/acdlite/a68433004f9d6b4cbc83b5cc3990c194\" class=\"markup--anchor markup--p-anchor\">new React Router V4</a>.</p><p id=\"0344\" class=\"graf graf--p graf-after--h3\">Here&#x2019;s a tip for getting code-splitting setup even faster. In React Router, a <a href=\"https://github.com/ReactTraining/react-router/blob/master/docs/API.md#route\" class=\"markup--anchor markup--p-anchor\">declarative route</a> for mapping a route &#x201C;/&#x201D; to a component `App` looks like &lt;Route path=&#x201D;/&#x201D; component={App}&gt;.</p><p id=\"f5c3\" class=\"graf graf--p graf-after--p\">React Router also supports a handy `<a href=\"https://github.com/ReactTraining/react-router/blob/master/docs/API.md#getcomponentnextstate-callback\" class=\"markup--anchor markup--p-anchor\">getComponent</a>` attribute, which is similar to `component` but is asynchronous and is <strong class=\"markup--strong markup--p-strong\">super nice</strong> for getting code-splitting setup quickly:</p><pre id=\"65fb\" class=\"graf graf--pre graf-after--p\">&lt;Route <br>   path=&quot;stories/:storyId&quot; <br>   getComponent={(nextState, cb) =&gt; {<br>   // async work to find components<br>  cb(null, Stories)<br>}} /&gt;</pre><p id=\"5d91\" class=\"graf graf--p graf-after--pre\">`getComponent` takes a function defining the next state (which I set to null) and a callback.</p><p id=\"02ba\" class=\"graf graf--p graf-after--p\">Let&#x2019;s add some route-based code-splitting to <a href=\"https://github.com/insin/react-hn\" class=\"markup--anchor markup--p-anchor\">ReactHN</a>. We&#x2019;ll start with a snippet from our <a href=\"https://github.com/insin/react-hn/blob/master/src/routes.js#L36\" class=\"markup--anchor markup--p-anchor\">routes</a> file&#x200A;&#x2014;&#x200A;this defines require calls for components and React Router routes for each route (e.g news, item, poll, job, comment permalinks etc):</p><pre id=\"c5f7\" class=\"graf graf--pre graf-after--p\">var IndexRoute = require(&apos;react-router/lib/IndexRoute&apos;)<br>var App = require(&apos;./App&apos;)<br>var Item = require(&apos;./Item&apos;)<br>var PermalinkedComment = require(&apos;./PermalinkedComment&apos;) &lt;--<br>var UserProfile = require(&apos;./UserProfile&apos;)<br>var NotFound = require(&apos;./NotFound&apos;)<br>var Top = stories(&apos;news&apos;, &apos;topstories&apos;, 500)<br>// ....</pre><pre id=\"09c7\" class=\"graf graf--pre graf-after--pre\">module.exports = &lt;Route path=&quot;/&quot; component={App}&gt;<br>  &lt;IndexRoute component={Top}/&gt;<br>  &lt;Route path=&quot;news&quot; component={Top}/&gt;<br>  &lt;Route path=&quot;item/:id&quot; component={Item}/&gt;<br>  &lt;Route path=&quot;job/:id&quot; component={Item}/&gt;<br>  &lt;Route path=&quot;poll/:id&quot; component={Item}/&gt;<br>  &lt;Route path=&quot;comment/:id&quot; component={PermalinkedComment}/&gt; &lt;---<br>  &lt;Route path=&quot;newcomments&quot; component={Comments}/&gt;<br>  &lt;Route path=&quot;user/:id&quot; component={UserProfile}/&gt;<br>  &lt;Route path=&quot;*&quot; component={NotFound}/&gt;<br>&lt;/Route&gt;</pre><p id=\"7bd5\" class=\"graf graf--p graf-after--pre\">ReactHN currently serve users a monolithic bundle of JS with code for <em class=\"markup--em markup--p-em\">all</em> routes. Let&#x2019;s switch it up to route-chunking and only serve exactly the code needed for a route, starting with comment permalinks (comment/:id):</p><p id=\"c44f\" class=\"graf graf--p graf-after--p\">So we first delete the implicit require for the permalink component:</p><pre id=\"fe7d\" class=\"graf graf--pre graf-after--p\">var PermalinkedComment = require(&#x2018;./PermalinkedComment&#x2019;)</pre><p id=\"c767\" class=\"graf graf--p graf-after--pre\">Then we take our route..</p><pre id=\"cf57\" class=\"graf graf--pre graf-after--p\">&lt;Route path=&#x201D;comment/:id&#x201D; component={PermalinkedComment}/&gt;</pre><p id=\"cebc\" class=\"graf graf--p graf-after--pre\">And update it with some declarative getComponent goodness. We&#x2019;ve got our require.ensure() call to lazy-load in our route and this is all we need to do for code-splitting:</p><pre id=\"e49f\" class=\"graf graf--pre graf-after--p\">&lt;Route<br>    path=&quot;comment/:id&quot;<br>    getComponent={(location, callback) =&gt; {<br>      require.ensure([], require =&gt; {<br>        callback(null, require(&apos;./PermalinkedComment&apos;))<br>      }, &apos;PermalinkedComment&apos;)<br>    }}<br>  /&gt;</pre><p id=\"276f\" class=\"graf graf--p graf-after--pre\">OMG beautiful. And..that&#x2019;s it. Seriously. We can apply this to the rest of our routes and run webpack. It will correctly find the require.ensure() calls and split our code as we intended.</p><figure id=\"258d\" class=\"graf graf--figure graf-after--p\"><img class=\"progressiveMedia-noscript js-progressiveMedia-inner\" src=\"https://cdn-images-1.medium.com/max/1600/0*glKcFK9_RLNk9AyR.\"></figure><p id=\"ab79\" class=\"graf graf--p graf-after--figure\">After applying declarative code-splitting to many more of our routes we can see our route-chunking in action, only loading up the code needed for a route (which we can precache in Service Worker) as needed:</p><figure id=\"06d0\" class=\"graf graf--figure graf-after--p\"><img class=\"progressiveMedia-noscript js-progressiveMedia-inner\" src=\"https://cdn-images-1.medium.com/max/1600/0*tVvolw4FTKjNFAnY.\"></figure><p id=\"3996\" class=\"graf graf--p graf-after--figure\">Reminder: A number of drop-in Webpack plugins for Service Worker caching are available:</p><ul class=\"postList\"><li id=\"f676\" class=\"graf graf--li graf-after--p\"><a href=\"https://github.com/goldhand/sw-precache-webpack-plugin\" class=\"markup--anchor markup--li-anchor\">sw-precache-webpack-plugin</a> which uses sw-precache under the hood</li><li id=\"50cf\" class=\"graf graf--li graf-after--li\"><a href=\"https://github.com/NekR/offline-plugin\" class=\"markup--anchor markup--li-anchor\">offline-plugin</a> which is used by react-boilerplate</li></ul><figure id=\"f45c\" class=\"graf graf--figure graf-after--h4\"><img class=\"progressiveMedia-noscript js-progressiveMedia-inner\" src=\"https://cdn-images-1.medium.com/max/1600/0*QphlrnwHQiOsB06w.\"></figure><p id=\"dc1c\" class=\"graf graf--p graf-after--figure\">To identify common modules used across different routes and put them in a commons chunk, use the <a href=\"https://webpack.github.io/docs/list-of-plugins.html#commonschunkplugin\" class=\"markup--anchor markup--p-anchor\">CommonsChunkPlugin</a>. It requires two script tags to be used per page, one for the commons chunk and one for the entry chunk for a route.</p><pre id=\"eece\" class=\"graf graf--pre graf-after--p\">const CommonsChunkPlugin = require(&quot;webpack/lib/optimize/CommonsChunkPlugin&quot;);<br>module.exports = {<br>    entry: {<br>        p1: &quot;./route-1&quot;,<br>        p2: &quot;./route-2&quot;,<br>        p3: &quot;./route-3&quot;<br>    },<br>    output: {<br>        filename: &quot;[name].entry.chunk.js&quot;<br>    },<br>    plugins: [<br>        new CommonsChunkPlugin(&quot;commons.chunk.js&quot;)<br>    ]<br>}</pre><p id=\"ae81\" class=\"graf graf--p graf-after--pre\">The Webpack&#x200A;<a href=\"https://blog.madewithlove.be/post/webpack-your-bags/\" class=\"markup--anchor markup--p-anchor\">&#x2014;&#x200A;display-chunks flag</a> is useful for seeing what modules occur in which chunks. This helps narrow down what dependencies are being duplicated in chunks and can hint at whether or not it&#x2019;s worth enabling the CommonChunksPlugin in your project. Here&#x2019;s a project with multiple components that detected a duplicate Mustache.js dependency between different chunks:</p><figure id=\"59e8\" class=\"graf graf--figure graf-after--p\"><img class=\"progressiveMedia-noscript js-progressiveMedia-inner\" src=\"https://cdn-images-1.medium.com/max/1600/0*YMvoz-W2HL3v2MIs.\"></figure><p id=\"2328\" class=\"graf graf--p graf-after--figure\">Webpack 1 also supports deduplication of libraries in your dependency trees using the <a href=\"https://github.com/webpack/docs/wiki/optimization#deduplication\" class=\"markup--anchor markup--p-anchor\">DedupePlugin</a>. In Webpack 2, tree-shaking should mostly eliminate the need for this.</p><p id=\"07d3\" class=\"graf graf--p graf-after--p\"><strong class=\"markup--strong markup--p-strong\">More Webpack tips</strong></p><ul class=\"postList\"><li id=\"7083\" class=\"graf graf--li graf-after--p\">The number of require.ensure() calls in your codebase generally correlates to the number of bundles that will be generated. It&#x2019;s useful to be aware of this when heavily using ensure across your codebase.</li><li id=\"cb17\" class=\"graf graf--li graf-after--li\"><a href=\"https://medium.com/modus-create-front-end-development/webpack-2-tree-shaking-configuration-9f1de90f3233\" class=\"markup--anchor markup--li-anchor\">Tree-shaking in Webpack2</a> will help remove unused exports. This can help keep your bundle sizes smaller.</li><li id=\"0039\" class=\"graf graf--li graf-after--li\">Also, be careful to avoid require.ensure() calls in common/shared bundles. You might find this creates entry point references which have assumptions about the dependencies that have already been loaded.</li><li id=\"17ba\" class=\"graf graf--li graf-after--li\">In Webpack 2, System.import does not currently work with server-rendering but I&#x2019;ve shared some notes about how to work around this on <a href=\"http://stackoverflow.com/a/39088208\" class=\"markup--anchor markup--li-anchor\">StackOverflow</a>.</li><li id=\"e97a\" class=\"graf graf--li graf-after--li\">If optimising for build speed, look at the <a href=\"https://github.com/webpack/docs/wiki/list-of-plugins\" class=\"markup--anchor markup--li-anchor\">Dll plugin</a>, <a href=\"https://www.npmjs.com/package/parallel-webpack\" class=\"markup--anchor markup--li-anchor\">parallel-webpack</a> and targeted builds</li><li id=\"ccc2\" class=\"graf graf--li graf-after--li\">If you need to <strong class=\"markup--strong markup--li-strong\">async</strong> or <strong class=\"markup--strong markup--li-strong\">defer</strong> scripts with Webpack, see <a href=\"https://github.com/numical/script-ext-html-webpack-plugin\" class=\"markup--anchor markup--li-anchor\">script-ext-html-webpack-plugin</a></li></ul><p id=\"7b1a\" class=\"graf graf--p graf-after--li\"><strong class=\"markup--strong markup--p-strong\">Detecting bloat in Webpack builds</strong></p><p id=\"0f0b\" class=\"graf graf--p graf-after--p\">The Webpack community have many web-established analysers for builds including <a href=\"http://webpack.github.io/analyse/\" class=\"markup--anchor markup--p-anchor\">http://webpack.github.io/analyse/</a>,<a href=\"http://webpack.github.io/analyse/\" class=\"markup--anchor markup--p-anchor\"> </a><a href=\"https://chrisbateman.github.io/webpack-visualizer/\" class=\"markup--anchor markup--p-anchor\">https://chrisbateman.github.io/webpack-visualizer/</a>,<a href=\"https://chrisbateman.github.io/webpack-visualizer/\" class=\"markup--anchor markup--p-anchor\"> </a>a<a href=\"https://chrisbateman.github.io/webpack-visualizer/\" class=\"markup--anchor markup--p-anchor\">n</a>d<a href=\"https://chrisbateman.github.io/webpack-visualizer/\" class=\"markup--anchor markup--p-anchor\"> </a><a href=\"https://alexkuz.github.io/stellar-webpack/\" class=\"markup--anchor markup--p-anchor\">https://alexkuz.github.io/stellar-webpack/.</a> These are handy for understanding what your largest modules are.</p><p id=\"820d\" class=\"graf graf--p graf-after--p\"><a href=\"https://github.com/danvk/source-map-explorer\" class=\"markup--anchor markup--p-anchor\"><strong class=\"markup--strong markup--p-strong\">source-map-explorer</strong></a> (via Paul Irish) is also <em class=\"markup--em markup--p-em\">fantastic</em> for understanding code bloat through source maps. Look at this tree-map visualisation with per-file LOC and % breakdowns for the ReactHN Webpack bundle:</p><figure id=\"4ffc\" class=\"graf graf--figure graf-after--p\"><img class=\"progressiveMedia-noscript js-progressiveMedia-inner\" src=\"https://cdn-images-1.medium.com/max/1600/0*D5j-Jv_FVkMigRyZ.\"></figure><p id=\"daa6\" class=\"graf graf--p graf-after--figure\">You might also be interested in <a href=\"https://github.com/samccone/coverage-ext\" class=\"markup--anchor markup--p-anchor\"><strong class=\"markup--strong markup--p-strong\">coverage-ext</strong></a> by Sam Saccone for generating code coverage for any webapp. This is useful for understanding how much code of the code you&#x2019;re shipping down is actually being executed.</p><p id=\"eb3c\" class=\"graf graf--p graf-after--h3\">Polymer discovered an interesting web performance pattern for granularly serving apps called <a href=\"https://www.polymer-project.org/1.0/toolbox/server\" class=\"markup--anchor markup--p-anchor\">PRPL</a> (see <a href=\"https://www.youtube.com/watch?v=J4i0xJnQUzU\" class=\"markup--anchor markup--p-anchor\">Kevin&#x2019;s I/O talk</a>). This pattern tries to optimise for interactivity and stands for:</p><ul class=\"postList\"><li id=\"037c\" class=\"graf graf--li graf-after--p\">(P)ush critical resources for the initial route</li><li id=\"ed9a\" class=\"graf graf--li graf-after--li\">(R)ender initial route and get it interactive as soon as possible</li><li id=\"12b4\" class=\"graf graf--li graf-after--li\">(P)re-cache the remaining routes using Service Worker</li><li id=\"66f4\" class=\"graf graf--li graf-after--li\">(L)azy-load and lazily instantiate parts of the app as the user moves through the application</li></ul></div><div class=\"section-inner sectionLayout--outsetColumn\"><figure id=\"88f7\" class=\"graf graf--figure graf--layoutOutsetCenter graf-after--li\"><img class=\"progressiveMedia-noscript js-progressiveMedia-inner\" src=\"https://cdn-images-1.medium.com/max/2000/0*2XxuNsDEp1-4VuoU.\"></figure></div><div class=\"section-inner sectionLayout--insetColumn\"><p id=\"1c9b\" class=\"graf graf--p graf-after--figure\">We have to give great kudos here to the <a href=\"https://shop.polymer-project.org/\" class=\"markup--anchor markup--p-anchor\">Polymer Shop demo</a> for showing us the way on real mobile devices. Using PRPL (in this case with HTML Imports, which can take advantage of the browser&#x2019;s background HTML parser). No pixels go on screen that you can&#x2019;t use. Additional work here is chunked and stays interactive. We&#x2019;re interactive on a real mobile device at 1.75seconds. 1.3s of JavaScript but it&#x2019;s all broken up. After that it all works.</p><p id=\"a1dc\" class=\"graf graf--p graf-after--p\">You&#x2019;re hopefully on board with the benefits of breaking down applications into more granular chunks by now. When a user first visits our PWA, let&#x2019;s say they go to a particular route. The server (using H/2 Push) can push down the chunks needed for just that route&#x200A;&#x2014;&#x200A;these are only the pieces needed to get the application booted up. Those go into the network cache.</p><p id=\"fb89\" class=\"graf graf--p graf-after--p\">Once they&#x2019;ve been pushed down, we&#x2019;ve effectively primed the cache with the chunks we know the page will need. When the application boots up, it looks at the route and knows that what we need is already in the cache, so we get that really fast first load of our application&#x200A;&#x2014;&#x200A;not just a splash screen&#x200A;&#x2014;&#x200A;but the interactive content the user asked for.</p><p id=\"41af\" class=\"graf graf--p graf-after--p\">The next part of this is rendering the content for the view as quickly as possible. The third is, while the user is looking at the current view, using Service Worker to start pre-caching all of the other chunks and routes the user hasn&#x2019;t asked for yet and getting those all installed into the Service Worker cache.</p><p id=\"1d49\" class=\"graf graf--p graf-after--p\">At this point the entire application (or a lot more of it) can be available offline. When a user navigates to a different part of the application, we can lazy load the next parts of it from the Service Worker cache. There&#x2019;s no network loading needed because they&#x2019;re already precached. Instant loading awesomeness ahoy! &#x2764;</p><p id=\"5f40\" class=\"graf graf--p graf-after--p\">PRPL can be applied to any app, as Flipkart recently demonstrated on their React stack. Apps fully using PRPL can take advantage of fast-loading using HTTP/2 server push by producing two builds that we conditionally serve depending on your browser support:</p><p id=\"2a2a\" class=\"graf graf--p graf-after--p\">* A bundled build optimised to minimize round-trips for servers/browsers without HTTP/2 Push support. For most of us, this is what we ship today by default.</p><p id=\"6036\" class=\"graf graf--p graf-after--p\">* An unbundled build for servers/browsers that do support HTTP/2 Push enabling a faster first-paint</p><p id=\"da9e\" class=\"graf graf--p graf-after--p\">This builds on some of the thinking we talked about earlier with route-chunking. With PRPL, the server and our Service Worker work together to precache resources for intactive routes. When a user navigates around your app and changes routes, we lazy-load resources for routes not cached yet and create the required views.</p><p id=\"4746\" class=\"graf graf--p graf-after--h3\"><strong class=\"markup--strong markup--p-strong\">tl;dr: Webpack&#x2019;s require.ensure() with an async &#x2018;getComponent&#x2019; and React Router are the lowest friction paths to a PRPL-style performance pattern</strong></p><figure id=\"86e4\" class=\"graf graf--figure graf-after--p\"><img class=\"progressiveMedia-noscript js-progressiveMedia-inner\" src=\"https://cdn-images-1.medium.com/max/1600/0*-llrY94drXMjBUW6.\"></figure><p id=\"031b\" class=\"graf graf--p graf-after--figure\">A big part of PRPL is turning the JS bundling mindset upside down and delivering resources as close to the granularity in which they are authored as possible (at least in terms of functionally independent modules). With Webpack, this is all about route-chunking which we&#x2019;ve already covered.</p><p id=\"8336\" class=\"graf graf--p graf-after--p\">Push critical resources for the initial route. Ideally, using <a href=\"https://www.igvita.com/2013/06/12/innovating-with-http-2.0-server-push/\" class=\"markup--anchor markup--p-anchor\">HTTP/2 Server Push</a> however don&#x2019;t let this be a blocker for trying to go down a PRPL-like path. You can achieve substantially similar results to &#x201C;full&#x201D; PRPL in many cases without using H/2 Push, but just sending <a href=\"https://www.smashingmagazine.com/2016/02/preload-what-is-it-good-for/\" class=\"markup--anchor markup--p-anchor\">preload headers</a> and H/2 alone.</p><p id=\"c59b\" class=\"graf graf--p graf-after--p\">See this production waterfall by Flipkart of their before/after wins:</p></div><div class=\"section-inner sectionLayout--outsetColumn\"><figure id=\"b09a\" class=\"graf graf--figure graf--layoutOutsetCenter graf-after--p\"><img class=\"progressiveMedia-noscript js-progressiveMedia-inner\" src=\"https://cdn-images-1.medium.com/max/2000/0*-hLp_Acvig_s4Uop.\"></figure></div><div class=\"section-inner sectionLayout--insetColumn\"><p id=\"97e3\" class=\"graf graf--p graf-after--figure\">Webpack has support for H/2 in the form of <a href=\"https://github.com/webpack/webpack/tree/master/examples/http2-aggressive-splitting\" class=\"markup--anchor markup--p-anchor\">AggressiveSplittingPlugin</a>.</p><p id=\"7091\" class=\"graf graf--p graf-after--p\">AggressiveSplittingPlugin splits every chunk until it reaches the specified maxSize as we can see with a short example below:</p><pre id=\"08a7\" class=\"graf graf--pre graf-after--p\">module.exports = {<br>    entry: &quot;./example&quot;,<br>    output: {<br>        path: path.join(__dirname, &quot;js&quot;),<br>        filename: &quot;[chunkhash].js&quot;,<br>        chunkFilename: &quot;[chunkhash].js&quot;<br>    },<br>    plugins: [<br>        new webpack.optimize.AggressiveSplittingPlugin({<br>            minSize: 30000,<br>            maxSize: 50000<br>        }),<br>// ...</pre><p id=\"ef95\" class=\"graf graf--p graf-after--pre\">See the official <a href=\"https://github.com/webpack/webpack/tree/master/examples/http2-aggressive-splitting\" class=\"markup--anchor markup--p-anchor\">plugin page</a> with examples for more details. <a href=\"https://docs.google.com/document/d/1K0NykTXBbbbTlv60t5MyJvXjqKGsCVNYHyLEXIxYMv0/preview?pref=2&amp;pli=1\" class=\"markup--anchor markup--p-anchor\">Lessons learned experimenting with HTTP/2 Push</a> and <a href=\"https://99designs.com.au/tech-blog/blog/2016/07/14/real-world-http-2-400gb-of-images-per-day/\" class=\"markup--anchor markup--p-anchor\">Real World HTTP/2</a> are also worth a read.</p><ul class=\"postList\"><li id=\"967e\" class=\"graf graf--li graf-after--p\">Rendering initial routes: this is really up to the framework/library you&#x2019;re using.</li><li id=\"5ce7\" class=\"graf graf--li graf-after--li\">Pre-caching remaining routes. For caching, we rely on Service Worker. <a href=\"https://github.com/GoogleChrome/sw-precache\" class=\"markup--anchor markup--li-anchor\">sw-precache</a> is great for generating a Service Worker for static asset precaching and for Webpack we can use <a href=\"https://www.npmjs.com/package/sw-precache-webpack-plugin\" class=\"markup--anchor markup--li-anchor\">SWPrecacheWebpackPlugin</a>.</li><li id=\"5472\" class=\"graf graf--li graf-after--li\">Lazy-load and create remaining routes on demand&#x200A;&#x2014;&#x200A;require.ensure() and System.import() are your friend in Webpack land.</li></ul><p id=\"1a97\" class=\"graf graf--p graf-after--h3\"><strong class=\"markup--strong markup--p-strong\">Why care about static asset versioning?</strong></p><p id=\"14cd\" class=\"graf graf--p graf-after--p\">Static assets refer to our page&#x2019;s static resources like scripts, stylesheets and images. When users visit our page for the first time, they need to download all of the resources used by the it. Let&#x2019;s say we land on a route and the JavaScript chunks needed haven&#x2019;t changed since the last time the page was visited&#x200A;&#x2014;&#x200A;we shouldn&#x2019;t have to re-fetch these scripts because they should already exist in the browser cache. Fewer network requests is a win for web performance.</p><p id=\"a9fe\" class=\"graf graf--p graf-after--p\">Normally, we accomplish this by setting up an <a href=\"https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=en\" class=\"markup--anchor markup--p-anchor\">expires header</a> for each of our files. An expires header just means that we can tell the browser to avoid making another request to the server for this file for a specific amount of time (e.g 1 year). As codebases evolve and are redeployed we want to make sure users get the freshest files without having to re-download resources if they haven&#x2019;t changed.</p><p id=\"0158\" class=\"graf graf--p graf-after--p\"><a href=\"https://css-tricks.com/strategies-for-cache-busting-css/\" class=\"markup--anchor markup--p-anchor\">Cache-busting</a> accomplishes this by appending a string to filenames&#x200A;&#x2014;&#x200A;it could be a build version (e.g src=&#x201D;chunk.js?v=1.2.0&#x201D;), a timestamp or something else. I prefer to adding a hash of the file contents to the filename (e.g chunk.d9834554decb6a8j.js) as this should always change when the contents of the file changes. MD5 hashing is commonly used in the Webpack community for this purpose which generates a &#x2018;summary&#x2019; value 16 bytes long.</p><p id=\"27d5\" class=\"graf graf--p graf-after--p\"><a href=\"https://medium.com/@okonetchnikov/long-term-caching-of-static-assets-with-webpack-1ecb139adb95\" class=\"markup--anchor markup--p-anchor\"><em class=\"markup--em markup--p-em\">Long-term caching of static-assets with Webpack</em></a><em class=\"markup--em markup--p-em\"> is an excellent read on this topic and you should check it out. I try to cover the main points of what&#x2019;s involved otherwise below.</em></p><p id=\"cc3b\" class=\"graf graf--p graf-after--p\"><strong class=\"markup--strong markup--p-strong\">Asset versioning using content-hashing in Webpack</strong></p><p id=\"6871\" class=\"graf graf--p graf-after--p\">In Webpack, asset versioning using content hashing is setup <a href=\"https://webpack.github.io/docs/long-term-caching.html\" class=\"markup--anchor markup--p-anchor\">[chunkhash]</a> in our Webpack config as follows:</p><pre id=\"269a\" class=\"graf graf--pre graf-after--p\"><strong class=\"markup--strong markup--pre-strong\">filename: &#x2018;[name].[chunkhash].js&#x2019;,<br>chunkFilename: &#x2018;[name].[chunkhash].js&#x2019;</strong></pre><p id=\"3d4c\" class=\"graf graf--p graf-after--pre\">We also want to make sure the normal [name].js and content-hashed ([name].[chunkhash].js) filenames are always correctly referenced in our HTML files. This is the difference between referencing &lt;script src=&#x201D;chunk&#x201D;.js&#x201D;&gt; and &lt;script src=&#x201D;chunk.d9834554decb6a8j.js&#x201D;&gt;.</p><p id=\"5e44\" class=\"graf graf--p graf-after--p\">Below is a commented Webpack config sample that includes a few other plugins that smooth over getting long-term caching setup.</p><pre id=\"db9a\" class=\"graf graf--pre graf-after--p\">const path = require(&apos;path&apos;);<br>const webpack = require(&apos;webpack&apos;);</pre><pre id=\"e9c2\" class=\"graf graf--pre graf-after--pre\">// Use webpack-manifest-plugin to generate asset manifests with a mapping from source files to their corresponding outputs. Webpack uses IDs instead of module names to keep generated files small in size. IDs get generated and mapped to chunk filenames before being put in the chunk manifest (which goes into our entry chunk). Unfortunately, any changes to our code update the entry chunk including the new manifest, invalidating our caching.<br>const ManifestPlugin = require(&apos;webpack-manifest-plugin&apos;);</pre><pre id=\"7073\" class=\"graf graf--pre graf-after--pre\">// We fix this with chunk-manifest-webpack-plugin, which puts the manifest in a completely separate JSON file of its own.<br>const ChunkManifestPlugin = require(&apos;chunk-manifest-webpack-plugin&apos;);</pre><pre id=\"9fd9\" class=\"graf graf--pre graf-after--pre\">module.exports = {<br>  entry: {<br>    vendor: &apos;./src/vendor.js&apos;,<br>    main: &apos;./src/index.js&apos;<br>  },<br>  output: {<br>    path: path.join(__dirname, &apos;build&apos;),<br>    filename: &apos;[name].[chunkhash].js&apos;,<br>    chunkFilename: &apos;[name].[chunkhash].js&apos;<br>  },<br>  plugins: [<br>    new webpack.optimize.CommonsChunkPlugin({<br>      name: &quot;vendor&quot;,<br>      minChunks: Infinity,<br>    }),<br>    new ManifestPlugin(),<br>    new ChunkManifestPlugin({<br>      filename: &quot;chunk-manifest.json&quot;,<br>      manifestVariable: &quot;webpackManifest&quot;<br>    }),<br>    // Work around non-deterministic ordering for modules. Covered more in the long-term caching of static assets with Webpack post.<br>    new webpack.optimize.OccurenceOrderPlugin() <br>  ]<br>};</pre><p id=\"c6a0\" class=\"graf graf--p graf-after--pre\">Now that we have a build of the chunk-manifest JSON, we need to inline it into our HTML so that Webpack actually has access to it when the page boots up. So include the output of the above in a &lt;script&gt; tag. Automatically inlining this script in HTML can be achieved using the <a href=\"https://github.com/ampedandwired/html-webpack-plugin\" class=\"markup--anchor markup--p-anchor\">html-webpack-plugin</a>.</p><p id=\"12b0\" class=\"graf graf--p graf-after--p\"><em class=\"markup--em markup--p-em\">Note: Webpack are hoping to simplify the steps required for this long-term caching setup from ~4&#x2013;1 by having </em><a href=\"https://github.com/webpack/webpack/tree/master/examples/explicit-vendor-chunk\" class=\"markup--anchor markup--p-anchor\"><em class=\"markup--em markup--p-em\">no shared ID range</em></a><em class=\"markup--em markup--p-em\">.</em></p><p id=\"4acc\" class=\"graf graf--p graf-after--p\">To learn more about HTTP <a href=\"https://jakearchibald.com/2016/caching-best-practices/\" class=\"markup--anchor markup--p-anchor\">Caching best practices</a>, read Jake Archibald&#x2019;s excellent write-up.</p><p id=\"dc3e\" class=\"graf graf--p graf-after--li\">In part 3 of this series, we&#x2019;ll look at <a href=\"https://medium.com/@addyosmani/progressive-web-apps-with-react-js-part-3-offline-support-and-network-resilience-c84db889162c#.tcspudthd\" class=\"markup--anchor markup--p-anchor\"><strong class=\"markup--strong markup--p-strong\">how to get your React PWA working offline and under flaky network conditions</strong></a>.</p><p id=\"7319\" class=\"graf graf--p graf-after--p\">If you&#x2019;re new to React, I&#x2019;ve found <a href=\"https://goo.gl/G1WGxU\" class=\"markup--anchor markup--p-anchor\">React for Beginners</a> by Wes Bos excellent.</p><p id=\"4808\" class=\"graf graf--p graf-after--p graf--trailing\"><em class=\"markup--em markup--p-em\">With thanks to Gray Norton, Sean Larkin, Sunil Pai, Max Stoiber, Simon Boudrias, Kyle Mathews and Owen Campbell-Moore for their reviews.</em></p></div></div></div></div>","author":"Addy Osmani","date_published":"2016-10-04T15:47:12.219Z","lead_image_url":"https://cdn-images-1.medium.com/max/1200/0*KlJk2hhZl3wyn6E4.","dek":null,"next_page_url":null,"url":"https://medium.com/@addyosmani/progressive-web-apps-with-react-js-part-2-page-load-performance-33b932d97cf2","domain":"medium.com","excerpt":"Part 2 of a new series walking through tips for shipping mobile web apps optimized using Lighthouse. This issue, we’ll be looking at page…","word_count":3377,"direction":"ltr","total_pages":2,"rendered_pages":1}
